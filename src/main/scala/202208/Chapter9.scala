package `202208`

object Chapter9 {

  /** EXERCISE 9.1
    *
    * productを使ってコンビネータmap2を実装し、これを使って、manyをベースとしてmany1を実装せよ。
    * ここまでの章と同様に、map2をプリミティブにし、map2をベースとしてproductを定義することもできる。
    * どちらを選択するかはあなた次第である。
    *
    * def map2[A, B, C](p: Parser[A], p2: Parser[B])(f: (A, B) => C): Parser[C]
    */

  /** EXERCISE 9.2
    *
    * productの振る舞いを定義する法則を考え出せ。
    */

  /** EXERCISE 9.3
    *
    * 先へ進む前に、or、map2、succeedをベースとしてmanyを定義できるか検討せよ。
    */

  /** EXERCISE 9.4
    *
    * map2とsucceedを使って先のlistOfNコンビネータを実装せよ。
    *
    * def listOfN[A](n: Int, p: Parser[A]): Parser[List[A]]
    */

  /** EXERCISE 9.5
    *
    * 第7章で示したように、非正格性に別のコンビネータで対処することもできる。
    * ここでもそれを試して、既存のコンビネータに必要な変更を追加せよ。
    * このアプローチをここで試すことについてどう思うか。
    */

  /** EXERCISE 9.6
    *
    * flatMapと他のコンビネータを使って、先ほど表現できなかった文脈依存パーサーを記述せよ。
    * 数字の解析には、正規表現をParserへ昇格させる新しいプリミティブregexを使用できる。
    * Scalaで文字列sを（マッチング用のメソッドが定義されている）Regexオブジェクトに処理させるには、s.rを"[a-zA-Z_][a-zA-Z0-9_]*".rのように使用すればよい。
    *
    * implicit def regex(r: Regex): Parser[String]
    */

  /** EXERCISE 9.7
    *
    * flatMapをベースとしてproductとmap2を実装せよ。
    */

  /** EXERCISE 9.8
    *
    * mapはもはやプリミティブではない。
    * flatMapや他のコンビネータをベースとして表現せよ。
    */

  /** EXERCISE 9.9
    *
    * ここからの作業はあなたに引き継いでもらう。
    * これまでに定義したプリミティブを使って、Parser[JSON]を一から作成せよ。
    * Parserの表現については（まだ）考えなくてよい。
    * 作業を進めていくうちに、コンビネータやイディオムが他にも発見され、共通のパターンがあることに気づいてそれらをリファクタリングすることになるだろう。
    * 本書で培ってきたスキルの見せどころである。
    * 行き詰まってしまった場合は、いつでも解答を調べてかまわない。
    * 以下に最低限のガイドラインをまとめておく。
    *
    * ・あなたが発見する汎用目的のコンビネータはすべてParsersトレイトに直接追加できる。
    * ・おそらく文字列リテラルや数字といったJSONフォーマットのトークンを解析するのに役立つコンビネータを追加したくなるだろう。
    *  これには、以前に追加したregexプリミティブを利用すればよい。
    *  また、トークンパーサーを構築するためにletter、digit、whitespaceなどのプリミティブを追加することもできる。
    *
    * さらにガイドラインが必要な場合のヒントも用意されている。
    * 完全なJSONパーサーはanswersのJSON.scalaファイルに含まれている。
    */

  /** EXERCISE 9.10
    *
    * Parserから報告されるエラーを表現するための便利なコンビネータがまだ見つかっていない場合は、ここでそれらを見つけ出せ。
    * コンビネータごとにその振る舞いを指定する法則を定義すること。
    * これは自由解答方式の設計タスクであり、以下にガイドラインとなる質問をまとめておく。
    *
    * ・`"abra".**(" ".many).**("cadabra")`というパーサーがあると仮定した場合、入力"abra cAdabra"に対してどのようなエラーを報告すればよいか（大文字の'A'に注意）。
    *  `Expected 'a'`のようなものだけでよいか、それとも`Expected "cadabra"`がよいか。
    *  "Magic word incorrect, try again!"のような別のエラーメッセージを選択したい場合はどうすればよいか。
    * ・a or bであると仮定した場合、aが入力で失敗したら必ずbを実行するのか、それとも、そうしたくない状況があるか。
    *  そうした状況がある場合、orが2つ目のパーサーを考慮すべきであることをプログラマが指定できる追加のコンビネータを思いつけるか。
    * ・エラーの場所を報告することにどのように対処したいか。
    * ・a or bであると仮定した場合、aとbの両方が入力で失敗したら両方のエラーを報告するのか。
    *  また、常に両方のエラーを報告するのか、それとも、2つのエラーのどちらを報告するのかをプログラマが指定できるようにするのか。
    */

  /** EXERCISE 9.11
    *
    * orで連結されている（1つ以上の）エラーのうちどれを報告するかをプログラマが指定できるようにする上で役立つプリミティブを他に思いつけるか。
    */

  /** EXERCISE 9.12
    *
    * 次項では、Parserの表現を取り上げ、その表現を使ってParsersインターフェイスを実装する。
    * だが、その前に自力で実装せよ。
    * これは自由解答形式の設計タスクだが、ここまで設計してきた代数により、表現として考えられるものに大きな制約が課される。
    * Parsersインターフェイスを実装するために使用できる、純粋関数型の単純なParser表現を思いつけるはずだ。
    * コードは以下のようになる可能性がある。
    *
    * class MyParser[+A](...){...}
    * object MyParsers extends Parsers[MyParser] {
    *   // プリミティブの実装
    * }
    *
    * MyParserは、パーサーを表現するために使用するデータ型と置き換える。
    * 満足のいくものに仕上がった場合、行き詰まった場合、あるいはヒントがもう少しほしい場合は、このまま読み進めること。
    */

  /** EXERCISE 9.13
    *
    * このParserの最初の表現に対するstring、regex、succeed、sliceを実装せよ。
    * sliceでは依然として削除するだけの値を生成しなければならないため、本来よりも非効率であることに注意。
    * これについては、後ほど改めて取り組む。
    */

  /** EXERCISE 9.14
    *
    * stringの実装を見直し、scopeやlabelを使って、エラーが発生した場合に意味のあるメッセージを提供するように変更せよ。
    */
}
